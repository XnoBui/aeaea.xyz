<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AEAEA - Digital Fashion & Innovation Studio</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@200;300;400;500;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="css/aeaea_company_website.css">
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>
<body>
    <!-- Navigation -->
    <nav>
        <div class="logo">
            <a href="#"><img src="images/aelogo_1.png" alt="AEAEA Logo"></a>
        </div>
        <div class="nav-links">
            <a href="#services">Services</a>
            <a href="#soma">Digital Humans</a>
            <a href="#fashion">Digital Fashion</a>
            <a href="#ar">AR</a>
            <a href="#metaverse">Metaverse</a>
            <a href="#contact">Contact</a>
        </div>
    </nav>

    <!-- Hero -->
    <section class="hero">
        <div id="container"></div>
        <div class="hero-content">
            <h1>Digital Innovation Studio</h1>
            <p>We are at the forefront of digital innovation, creating cutting-edge digital humans, virtual fashion, immersive AR experiences, and metaverse spaces</p>
        </div>
        <div class="scroll-indicator">‚Üì</div>
    </section>

    <!-- Services Overview -->
    <section id="services" class="services-overview">
        <div class="section-header">
            <h2>What We Do</h2>
            <p>We offer four specialized services that are shaping the digital future.</p>
        </div>
        
        <div class="services-grid">
            <div class="service-card">
                <div class="service-number">01</div>
                <h3>Digital Humans</h3>
                <p>SOMA - Professional digital humans for campaigns, content, and partnerships. Luna, Riven, and more.</p>
                <a href="#soma" class="service-link">Learn more ‚Üí</a>
            </div>
            
            <div class="service-card">
                <div class="service-number">02</div>
                <h3>Digital Fashion</h3>
                <p>Virtual clothing and accessories. From concept to 3D modeling. For games, metaverse, and social media.</p>
                <a href="#fashion" class="service-link">Learn more ‚Üí</a>
            </div>
            
            <div class="service-card">
                <div class="service-number">03</div>
                <h3>AR Experiences</h3>
                <p>Augmented reality filters, try-ons, and interactive experiences. Instagram, Snapchat, and custom apps.</p>
                <a href="#ar" class="service-link">Learn more ‚Üí</a>
            </div>
            
            <div class="service-card">
                <div class="service-number">04</div>
                <h3>Metaverse Spaces</h3>
                <p>Virtual worlds, showrooms, and event spaces. Spatial design for Decentraland, Roblox, and custom platforms.</p>
                <a href="#metaverse" class="service-link">Learn more ‚Üí</a>
            </div>
        </div>
    </section>

    <!-- SOMA Digital Humans -->
    <section id="soma" class="service-detail">
        <div class="service-content">
            <div class="service-info">
                <h3>SOMA Digital Humans</h3>
                <p>Our digital humans work like real talent. They create content, engage audiences, and represent brands. Each has their own personality, style, and growing fanbase.</p>
                <ul class="service-features">
                    <li>5 established digital humans with real followers</li>
                    <li>Fashion campaigns and brand partnerships</li>
                    <li>Music creation and performances</li>
                    <li>24/7 availability, no geographic limits</li>
                    <li>AI-powered conversations and content</li>
                </ul>
                <a href="https://soma.ai" class="service-link">Visit SOMA ‚Üí</a>
            </div>
            <div class="service-visual">SOMA</div>
        </div>
    </section>

    <!-- Digital Fashion -->
    <section id="fashion" class="service-detail">
        <div class="service-content">
            <div class="service-info">
                <h3>Digital Fashion</h3>
                <p>We design and create virtual clothing that exists purely in digital spaces. From haute couture to streetwear, our pieces can be worn in photos, videos, games, and virtual worlds.</p>
                <ul class="service-features">
                    <li>3D garment design and modeling</li>
                    <li>Virtual try-on technology</li>
                    <li>NFT fashion collections</li>
                    <li>Game-ready wearables</li>
                    <li>Social media fashion filters</li>
                </ul>
                <a href="#contact" class="service-link">Start a project ‚Üí</a>
            </div>
            <div class="service-visual">FASHION</div>
        </div>
    </section>

    <!-- AR Experiences -->
    <section id="ar" class="service-detail">
        <div class="service-content">
            <div class="service-info">
                <h3>AR Experiences</h3>
                <p>Augmented reality that bridges physical and digital. We create filters, effects, and interactive experiences that transform how people engage with brands and content.</p>
                <ul class="service-features">
                    <li>Instagram and Snapchat filters</li>
                    <li>Virtual try-on for products</li>
                    <li>Interactive AR campaigns</li>
                    <li>WebAR experiences</li>
                    <li>Custom AR applications</li>
                </ul>
                <a href="#contact" class="service-link">Create AR experience ‚Üí</a>
            </div>
            <div class="service-visual">AR</div>
        </div>
    </section>

    <!-- Metaverse Spaces -->
    <section id="metaverse" class="service-detail">
        <div class="service-content">
            <div class="service-info">
                <h3>Metaverse Spaces</h3>
                <p>Virtual environments where people gather, shop, and experience. We design and build spaces that feel alive, from intimate showrooms to massive event venues.</p>
                <ul class="service-features">
                    <li>Virtual showrooms and galleries</li>
                    <li>Event spaces and concert venues</li>
                    <li>Roblox and Decentraland builds</li>
                    <li>Custom virtual worlds</li>
                    <li>Spatial UX design</li>
                </ul>
                <a href="#contact" class="service-link">Build your space ‚Üí</a>
            </div>
            <div class="service-visual">META</div>
        </div>
    </section>

    <!-- Showcase -->
    <section class="showcase-section">
        <div class="section-header">
            <h2>Selected Work</h2>
        </div>
        <div class="showcase-grid">
            <div class="showcase-item">üì∏</div>
            <div class="showcase-item">üëó</div>
            <div class="showcase-item">üé≠</div>
            <div class="showcase-item">üåê</div>
            <div class="showcase-item">‚ú®</div>
            <div class="showcase-item">üéµ</div>
            <div class="showcase-item">üèõÔ∏è</div>
            <div class="showcase-item">üëÅÔ∏è</div>
        </div>
    </section>

    <!-- About -->
    <section class="about-section">
        <h2>About AEAEA</h2>
        <p>We are a digital innovation studio at the intersection of fashion, technology, and human expression.</p>
        <p>After years of R&D, we're excited to share our vision of digital humanity through practical applications.</p>
        
        <div class="team-info">
            <h3>YGILABS</h3>
            <p>Founded by a team with backgrounds in fashion design, interior design, and technology. We believe the future is both digital and deeply human.</p>
        </div>
    </section>

    <!-- Contact -->
    <section id="contact" class="contact-section">
        <div class="contact-content">
            <h2>Start a Project</h2>
            <div class="contact-info">
                <div class="contact-item">
                    <h4>General Inquiries</h4>
                    <p><a href="mailto:hello@aeaea.xyz">hello@aeaea.xyz</a></p>
                </div>
                <div class="contact-item">
                    <h4>SOMA Bookings</h4>
                    <p><a href="mailto:soma@aeaea.xyz">soma@aeaea.xyz</a></p>
                </div>
            </div>
            <p style="color: #666;">Contact us for project inquiries</p>
        </div>
    </section>

    <!-- Footer -->
    <footer>
        <p>¬© 2025 AEAEA by YGILABS. Creating the digital future.</p>
    </footer>

    <!-- Bottom Navigation -->
    <div class="bottom-nav">
        <a href="#services" class="bottom-nav-link">
            <span>Services</span>
        </a>
        <a href="#soma" class="bottom-nav-link">
            <span>Digital Humans</span>
        </a>
        <a href="#fashion" class="bottom-nav-link">
            <span>Digital Fashion</span>
        </a>
        <a href="#ar" class="bottom-nav-link">
            <span>AR</span>
        </a>
        <a href="#contact" class="bottom-nav-link">
            <span>Contact</span>
        </a>
    </div>
    <script type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

        let scene, camera, renderer, model, mixer, clock;
        let morphTargets = {};
        let blinkTimer = 0;
        let nextBlinkTime = Math.random() * 3 + 2;
        let isBlinking = false;
        let blinkDuration = 0.3; // Slower, more natural blink duration
        let currentBlinkTime = 0;

        function init() {
            console.log('Initializing enhanced SOMA model viewer...');
            
            const container = document.getElementById('container');
            if (!container) {
                console.error('Container not found');
                return;
            }
            
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(35, window.innerWidth / window.innerHeight, 0.1, 1000);
            renderer = new THREE.WebGLRenderer({ alpha: true, antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setClearColor(0x000000, 0);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.2;
            
            container.appendChild(renderer.domElement);

            // Load the SOMA model
            const loader = new GLTFLoader();
            
            const possiblePaths = [
                './SOMA MODEL ANIMATION TEST.glb',
                'SOMA MODEL ANIMATION TEST.glb',
                './SOMA%20MODEL%20ANIMATION%20TEST.glb',
                'SOMA%20MODEL%20ANIMATION%20TEST.glb'
            ];
            
            let currentPathIndex = 0;
            
            function tryLoadModel() {
                if (currentPathIndex >= possiblePaths.length) {
                    console.error('Could not load SOMA model from any path');
                    return;
                }
                
                const currentPath = possiblePaths[currentPathIndex];
                console.log(`Trying to load SOMA model from: ${currentPath}`);
                
                loader.load(
                    currentPath,
                    function (gltf) {
                        console.log('SOMA model loaded successfully');
                        model = gltf.scene;
                        
                        // Position the model
                        model.position.set(0, -6.8, 0);
                        model.scale.set(7, 5, 7);
                        
                        // Setup enhanced model features
                        setupModelEnhancements(model);
                        
                        scene.add(model);
                        
                        // Setup animations if available
                        if (gltf.animations && gltf.animations.length > 0) {
                            mixer = new THREE.AnimationMixer(model);
                            gltf.animations.forEach((clip) => {
                                const action = mixer.clipAction(clip);
                                action.play();
                            });
                        }

                        // Apply default pleasant expression
                        setTimeout(() => {
                            applyDefaultExpression();
                        }, 100);
                    },
                    function(progress) {
                        console.log('Loading progress:', (progress.loaded / progress.total * 100) + '%');
                    },
                    function (error) {
                        console.error(`Error loading model from ${currentPath}:`, error);
                        currentPathIndex++;
                        tryLoadModel();
                    }
                );
            }
            
            tryLoadModel();

            // Enhanced lighting setup for facial features
            setupLighting();

            // Position camera
            camera.position.set(0, 1.2, 2.5);
            camera.lookAt(0, 1.2, 0);

            // Animation clock
            clock = new THREE.Clock();

            animate();
        }

        function setupModelEnhancements(model) {
            model.traverse(function(child) {
                if (child.isMesh) {
                    child.castShadow = true;
                    child.receiveShadow = true;
                    
                    // Look for facial meshes and setup morphing
                    if (child.name.toLowerCase().includes('face') || 
                        child.name.toLowerCase().includes('head') ||
                        child.name.toLowerCase().includes('eye') ||
                        child.name.toLowerCase().includes('mouth') ||
                        child.name.toLowerCase().includes('brow')) {
                        
                        // Store eye meshes for tracking
                        if (child.name.toLowerCase().includes('eye')) {
                            eyeMeshes.push(child);
                            console.log('Found eye mesh for tracking:', child.name);
                        }
                        
                        // Create artificial morph targets for facial expressions
                        setupArtificialMorphTargets(child);
                    }
                    
                    // Enhance materials
                    if (child.material) {
                        const materials = Array.isArray(child.material) ? child.material : [child.material];
                        materials.forEach(material => {
                            if (material.isMeshStandardMaterial || material.isMeshPhysicalMaterial) {
                                material.metalness = material.metalness || 0.1;
                                material.roughness = material.roughness || 0.4;
                                material.envMapIntensity = 1.2;
                                
                                // Enhance skin materials
                                if (material.name && material.name.toLowerCase().includes('skin')) {
                                    material.roughness = 0.6;
                                    material.metalness = 0.0;
                                    material.transparent = true;
                                    material.opacity = 0.95;
                                }
                            }
                        });
                    }
                }
            });
        }

        function setupArtificialMorphTargets(mesh) {
            morphTargets[mesh.uuid] = {
                mesh: mesh,
                originalScale: mesh.scale.clone(),
                originalPosition: mesh.position.clone(),
                originalRotation: mesh.rotation.clone()
            };
        }

        function setupLighting() {
            // Key light for main illumination
            const keyLight = new THREE.DirectionalLight(0xffffff, 3.0);
            keyLight.position.set(2, 4, 3);
            keyLight.castShadow = true;
            keyLight.shadow.mapSize.width = 2048;
            keyLight.shadow.mapSize.height = 2048;
            scene.add(keyLight);

            // Fill light to soften shadows
            const fillLight = new THREE.DirectionalLight(0xfff8e1, 1.5);
            fillLight.position.set(-2, 2, 2);
            scene.add(fillLight);

            // Rim light for depth
            const rimLight = new THREE.DirectionalLight(0xe3f2fd, 2.0);
            rimLight.position.set(0, 3, -2);
            scene.add(rimLight);

            // Soft ambient light
            const ambientLight = new THREE.AmbientLight(0xf5f5f5, 0.8);
            scene.add(ambientLight);

            // Focused face light
            const faceLight = new THREE.SpotLight(0xffffff, 2.5, 8, Math.PI / 8, 0.2);
            faceLight.position.set(0, 4, 1.5);
            faceLight.target.position.set(0, 0, 0);
            scene.add(faceLight);
            scene.add(faceLight.target);
        }

        function applyDefaultExpression() {
            if (!model) return;

            console.log('Applying default expression...');
            
            // Apply a pleasant, natural expression with more natural eye openness
            const eyeOpenness = 0.5; // Natural eye openness, not too wide
            const smileIntensity = 0.3;
            const eyebrowRaise = 0.2;
            const jawOpen = 0.05;

            // First, let's log all mesh names to understand the model structure
            model.traverse(function(child) {
                if (child.isMesh) {
                    console.log('Found mesh:', child.name, 'Type:', child.type);
                }
            });

            model.traverse(function(child) {
                if (child.isMesh && morphTargets[child.uuid]) {
                    const target = morphTargets[child.uuid];
                    
                    // Eye effects - use natural eyelid movement instead of scaling
                    if (child.name.toLowerCase().includes('eye')) {
                        console.log('Applying eye expression to:', child.name);
                        // Simulate natural eyelid movement with position and rotation
                        const closeFactor = 1 - eyeOpenness;
                        child.position.y = target.originalPosition.y - closeFactor * 0.02;
                        child.rotation.x = target.originalRotation.x + closeFactor * 0.1;
                        child.visible = true; // Always keep eyes visible
                        
                        // Very subtle scale adjustment only for extreme closure
                        if (eyeOpenness < 0.3) {
                            child.scale.y = target.originalScale.y * (0.85 + eyeOpenness * 0.15);
                        } else {
                            child.scale.y = target.originalScale.y;
                        }
                    }
                    
                    // Mouth/smile effects - subtle smile
                    if (child.name.toLowerCase().includes('mouth') || 
                        child.name.toLowerCase().includes('lip')) {
                        console.log('Applying smile expression to:', child.name);
                        child.scale.x = target.originalScale.x * (1 + smileIntensity * 0.2);
                        child.position.y = target.originalPosition.y + smileIntensity * 0.1;
                    }
                    
                    // Eyebrow effects - slight raise for alertness
                    if (child.name.toLowerCase().includes('brow') || 
                        child.name.toLowerCase().includes('eyebrow')) {
                        console.log('Applying eyebrow expression to:', child.name);
                        child.position.y = target.originalPosition.y + eyebrowRaise * 0.2;
                    }
                    
                    // Jaw effects - slightly open for natural look
                    if (child.name.toLowerCase().includes('jaw') || 
                        child.name.toLowerCase().includes('chin')) {
                        console.log('Applying jaw expression to:', child.name);
                        child.position.y = target.originalPosition.y - jawOpen * 0.3;
                    }
                }
            });
        }

        function handleBlinking(delta) {
            blinkTimer += delta;

            if (!isBlinking && blinkTimer >= nextBlinkTime) {
                // Start blink
                isBlinking = true;
                currentBlinkTime = 0;
                blinkTimer = 0;
                nextBlinkTime = Math.random() * 4 + 2; // Next blink in 2-6 seconds
            }

            if (isBlinking) {
                currentBlinkTime += delta;
                
                // Calculate blink progress (0 to 1 and back to 0)
                let blinkProgress;
                if (currentBlinkTime < blinkDuration / 2) {
                    blinkProgress = (currentBlinkTime / (blinkDuration / 2));
                } else if (currentBlinkTime < blinkDuration) {
                    blinkProgress = 1 - ((currentBlinkTime - blinkDuration / 2) / (blinkDuration / 2));
                } else {
                    blinkProgress = 0;
                    isBlinking = false;
                }

                // Apply realistic blink to eyes using natural eyelid movement
                const baseEyeOpenness = 0.5; // Default eye openness - matches the natural setting
                const blinkCloseFactor = blinkProgress * 0.4; // Reduced intensity to prevent eye disappearing
                
                model.traverse(function(child) {
                    if (child.isMesh && child.name.toLowerCase().includes('eye') && morphTargets[child.uuid]) {
                        const target = morphTargets[child.uuid];
                        
                        // Simulate natural eyelid closure with position and rotation only
                        const totalCloseFactor = (1 - baseEyeOpenness) + blinkCloseFactor;
                        child.position.y = target.originalPosition.y - totalCloseFactor * 0.015; // Reduced movement
                        child.rotation.x = target.originalRotation.x + totalCloseFactor * 0.05; // Reduced rotation
                        child.visible = true; // Always keep eyes visible
                        
                        // NO scaling during blink to prevent eyes from disappearing
                        child.scale.y = target.originalScale.y;
                    }
                });
            }
        }

        function animate() {
            requestAnimationFrame(animate);
            
            const delta = clock.getDelta();
            
            // Update animations
            if (mixer) {
                mixer.update(delta);
            }
            
            // Handle natural blinking
            handleBlinking(delta);
            
            // Update eye tracking
            updateEyeTracking();
            
            renderer.render(scene, camera);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // Enhanced mouse tracking variables
        let mousePosition = { x: 0, y: 0 };
        let eyeMeshes = [];
        let smoothMousePosition = { x: 0, y: 0 };
        let targetEyeRotation = { x: 0, y: 0 };
        let currentEyeRotation = { x: 0, y: 0 };
        let eyeVelocity = { x: 0, y: 0 };
        
        // Enhanced professional eye tracking parameters
        const eyeTrackingSpeed = 0.18;
        const mouseSmoothing = 0.25;
        const maxEyeRotation = { x: 0.4, y: 0.5 };
        const eyeAcceleration = 0.12;
        const eyeDamping = 0.88;
        const deadZone = 0.015;

        function updateEyeTracking() {
            if (!model || eyeMeshes.length === 0) return;
            
            // Professional smooth mouse position filtering
            smoothMousePosition.x += (mousePosition.x - smoothMousePosition.x) * mouseSmoothing;
            smoothMousePosition.y += (mousePosition.y - smoothMousePosition.y) * mouseSmoothing;

            // Enhanced target eye rotation with proper vertical tracking
            targetEyeRotation.x = -smoothMousePosition.y * maxEyeRotation.x; // Up/down eye movement
            targetEyeRotation.y = smoothMousePosition.x * maxEyeRotation.y;  // Left/right eye movement

            // Apply dead zone to prevent micro-movements
            const deltaX = targetEyeRotation.x - currentEyeRotation.x;
            const deltaY = targetEyeRotation.y - currentEyeRotation.y;
            
            if (Math.abs(deltaX) > deadZone || Math.abs(deltaY) > deadZone) {
                // Calculate velocity-based acceleration for natural movement
                eyeVelocity.x += deltaX * eyeAcceleration;
                eyeVelocity.y += deltaY * eyeAcceleration;
                
                // Apply damping to velocity for smooth deceleration
                eyeVelocity.x *= eyeDamping;
                eyeVelocity.y *= eyeDamping;
                
                // Update current eye rotation with velocity
                currentEyeRotation.x += eyeVelocity.x;
                currentEyeRotation.y += eyeVelocity.y;
                
                // Smooth interpolation towards target for final precision
                currentEyeRotation.x += (targetEyeRotation.x - currentEyeRotation.x) * eyeTrackingSpeed;
                currentEyeRotation.y += (targetEyeRotation.y - currentEyeRotation.y) * eyeTrackingSpeed;
            }

            // Apply eye tracking to all eye meshes
            eyeMeshes.forEach(eyeMesh => {
                if (morphTargets[eyeMesh.uuid]) {
                    const target = morphTargets[eyeMesh.uuid];
                    
                    // Enhanced eye tracking with proper vertical movement physics
                    const finalRotationX = target.originalRotation.x + currentEyeRotation.x;
                    const finalRotationY = target.originalRotation.y + currentEyeRotation.y;
                    const finalRotationZ = target.originalRotation.z + (currentEyeRotation.x * 0.1);
                    
                    // Professional smooth transition
                    const adaptiveSpeed = 0.3;
                    eyeMesh.rotation.x += (finalRotationX - eyeMesh.rotation.x) * adaptiveSpeed;
                    eyeMesh.rotation.y += (finalRotationY - eyeMesh.rotation.y) * adaptiveSpeed;
                    eyeMesh.rotation.z += (finalRotationZ - eyeMesh.rotation.z) * adaptiveSpeed;
                    
                    // Subtle position adjustments for realistic eye movement
                    const targetPositionX = target.originalPosition.x + currentEyeRotation.y * 0.004;
                    const targetPositionZ = target.originalPosition.z + currentEyeRotation.x * 0.003;
                    eyeMesh.position.x += (targetPositionX - eyeMesh.position.x) * 0.2;
                    eyeMesh.position.z += (targetPositionZ - eyeMesh.position.z) * 0.2;
                }
            });
        }

        function onMouseMove(event) {
            // Update mouse position for eye tracking
            mousePosition.x = (event.clientX / window.innerWidth) * 2 - 1;
            mousePosition.y = -(event.clientY / window.innerHeight) * 2 + 1;
            
            if (model) {
                // Enhanced head and neck movement with proper face tracking
                // Horizontal movement - head turns left/right (Y rotation)
                const targetHeadRotationY = mousePosition.x * 0.08; // Reduced intensity
                
                // Vertical movement - head tilts up/down (X rotation) - FIXED: No position changes
                const targetHeadRotationX = mousePosition.y * 0.06; // Reduced intensity
                
                // Smooth interpolation for natural head movement
                const headLerpSpeed = 0.08;
                model.rotation.y += (targetHeadRotationY - model.rotation.y) * headLerpSpeed;
                model.rotation.x += (targetHeadRotationX - model.rotation.x) * headLerpSpeed;
                
                // Add very subtle Z rotation for more realistic neck movement
                const targetHeadRotationZ = mousePosition.y * mousePosition.x * 0.01;
                model.rotation.z += (targetHeadRotationZ - model.rotation.z) * headLerpSpeed;
                
                // REMOVED: Position adjustments that were causing zoom effect
                // Keep the model at its fixed position to prevent zoom in/out
            }
        }

        window.addEventListener('resize', onWindowResize, false);
        document.addEventListener('mousemove', onMouseMove, false);

        // Initialize when DOM is ready
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', init);
        } else {
            init();
        }
    </script>
</body>
</html>
